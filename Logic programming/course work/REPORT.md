# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Минеева Светлана Алексеевна

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [x] стандартный, с NLP (на 3-4)
 - [ ] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В ходе выполнения данной курсовой работы я получу важные теоретические и практические навыки программирования на логическом языке программирования Prolog, а именно:

1) Изучу представление данных в файлах формата GEDCOM;
2) Научусь писать парсер, преобразующий данные из файла формата GEDCOM в набор утверждений на логическом языке программирования Prolog;
3) Лучше разберусь в работе с деревьями на языке Prolog;
4) Научусь реализовывать естественно-языковой интерфейс к программам.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM;
2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление:
     4) с использованием предикатов `father(отец, потомок)` и `mother(мать, потомок)`
Для преобразования будет использован язык программирования Prolog;
3. Реализовать предикат проверки/поиска следующих родственников:
     6) Теща;
4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве;
5. Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. Допускается использовать английский язык в качестве базового. Для отличной оценки требуется:
•	Учесть контекст (возможность использования it/him/her с отсылкой на упомянутый на прошлом шаге объект)
•	Выполнять запросы относительно количества (How many brothers does Mary have?)
•	Выполнить разбор предложения с построением смысловой модели.

## Получение родословного дерева

Для создания родословного дерева я использовала сервис familyecho.com (ссылка: https://www.familyecho.com). Это очень удобный online сервис с максимально простым интерфейсом, вывод дерева возможен в различных форматах в том числе в расширении ged, требующимся для выполнения задания. В моём родословном дереве получилось 58 индивидуумов и 5 поколений.

 

## Конвертация родословного дерева

Для конвертации родословного дерева я использовала язык программирования Prolog, так как в нем удобно синтаксически анализировать данные. Алгоритм заключается в последовательном прочтении строк файла GEDCOM, анализа данных этих строк на нужную информацию. Интерес представляют строки с именами и фамилиями индивидуумов, а также строки с указанием информации о родителях индивидуума. Указателями на эти данные служат такие ключевые слова, как INDI – обозначение начала описания индивидуума, FAM – обозначение начала описания информации о семье, GIVN – строка с именем, _MARNM – строка с фамилией. Изображение родословного дерева представлено в файле "Родословное дерево.jpg".

Пример представления данных в файле формата GEDCOM:

```prolog
0 @I3@ INDI
1 NAME Ольга /Кустова/
2 GIVN Ольга
2 SURN Кустова
2 _MARNM Минеева
1 SEX F
1 FAMS @F1@
1 FAMC @F3@
```

Стоит отметить наличие двух строк с информацией о фамилии. Одна из них (SURN) – это фамилия при рождении, вторая (_MARNM) - при женитьбе. Считаю более логичным добавление в утверждения на языке Prolog фамилию при женитьбе, так как обычно в деревьях у жены хранится фамилия мужа.

Основные функции отбора данных:

```prolog
% Получение имени и фамилии индивидуума
get_id_line(Number, [First_element, Second_element, Third_element|_], Id, End) :-
    First_element = "0",
    Third_element = "INDI",
    Second_element = Id,
    read_string(Number, "\n", "\r", _, _), % пропуск строки вида: имя /фамилия/
    read_string(Number, "\n", "\r", _, Name),
    split_string(Name, " ", "", Name_list),
    get_third_element(Name_list, Resulting_Name),
    read_string(Number, "\n", "\r", _, _), % пропуск строки с фамилией, которую индивидуум имел при рождении
    read_string(Number, "\n", "\r", _, Surname),
    split_string(Surname, " ", "", Surname_list),
    get_third_element(Surname_list, Resulting_Surname),
    string_concat(Resulting_Name, " ", Result),
    string_concat(Result, Resulting_Surname, End).

get_id_line(_, _, _, _).
```

```prolog
% Проверка: является ли строка информацией о родителях индивидуума
line_split(Input, Output, [First_element, _, Third_element|_]) :-
    First_element = "0",
    Third_element = "FAM",
    read_string(Input, "\n", "\r", _, Husband_string),
    split_string(Husband_string, " ", "", Husband_list),
    get_third_element(Husband_list, Husband),
    read_string(Input, "\n", "\r", _, Wife_string),
    split_string(Wife_string, " ", "", Wife_list),
    get_third_element(Wife_list, Wife),
    read_childs(Input, Child),
    print_result(Husband, Wife, Child, Output), !.

line_split(_, _, _).
```

После получения всей интересующей нас информации об индивидууме оформляем эти данные в виде предикатов `father(отец, потомок)` и `mother(мать, потомок)`.

```prolog
% Запись данных в формате предикатов father(отец, потомок) и mother(мать, потомок) 
print_result(_, _, [], _).

print_result(Husband_id, Wife_id, [Person_id|Child_id], Output) :-
    get_id(Person_id, H),
    get_id(Husband_id, Husband),
    get_id(Wife_id, Wife),
    write(Output, "father(\""), write(Output, Husband), write(Output, "\", \""), write(Output, H), write(Output, "\").\n"),
    write(Output, "mother(\""), write(Output, Wife), write(Output, "\", \""), write(Output, H), write(Output, "\").\n"),
    print_result(Husband_id, Wife_id, Child_id, Output).
```

## Предикат поиска родственника

По заданию требуется реализовать предикат поиска тёщи. Тёща – это мать жены. Идея предиката весьма проста: если у мужчины есть жена (это проверяется по наличию общего ребенка), то женщина, являющаяся матерью его жены, есть его теща. При реализации предиката поиска тёщи потребуется использование встроенного предиката `discontiguous`, поскольку набор утверждений, составленный по родословному дереву, не имеет упорядоченный вид, то есть файл My_family.pl имеет вид не сначала полного перечисления предиката `father`, а потом `mother`, а смеси предикатов).

```prolog
:- discontiguous father/2.
:- discontiguous mother/2.

:- include("My_family.pl").

mother_in_law(Mother_in_law, Person):-
    mother(Mother_in_law, Wife),
    mother(Wife, Child),
    father(Person, Child).
```

Примеры запросов:

```prolog
?- mother_in_law(X,Y).
X = "Валентина Кустова",
Y = "Алексей Минеев" ;
X = "Анастасия Тихонова",
Y = "Владимир Минеев" ;
X = "Анастасия Тихонова",
Y = "Владимир Минеев" ;
X = "Анастасия Куликова",
Y = "Валентин Кустов" ;
X = "Анастасия Куликова",
Y = "Валентин Кустов" ;
X = "Анастасия Куликова",
Y = "Владимир Нестеров" ;
X = "Анастасия Куликова",
Y = "Владимир Нестеров" ;
X = "Анастасия Куликова",
Y = "Влад Смирнов" ;
X = "Елена Фролова",
Y = "Александр Минеев" ;
X = "Анна Макарова",
Y = "Виктор Тихонов" ;
X = "Анна Макарова",
Y = "Виктор Тихонов" ;
X = "Варвара Свердлова",
Y = "Григорий Кустов" ;
X = "Дарья Куликова",
Y = "Павел Куликов" ;
X = "Дарья Куликова",
Y = "Павел Куликов" ;
X = "Дарья Куликова",
Y = "Павел Куликов" ;
X = "Дарья Куликова",
Y = "Павел Куликов" ;
X = "Елизавета Кондратьева",
Y = "Павел Куликов" ;
X = "Елизавета Кондратьева",
Y = "Павел Куликов" ;
X = "Елизавета Кондратьева",
Y = "Павел Куликов" ;
X = "Елизавета Кондратьева",
Y = "Павел Куликов" ;
X = "Дарья Смирнова",
Y = "Денис Горюнов" ;
X = "Мария Нестерова",
Y = "Андрей Соколов" ;
false.

?- mother_in_law(X, "Алексей Минеев").
X = "Валентина Кустова" ;
false.

?- mother_in_law("Валентина Кустова", Y).
Y = "Алексей Минеев" ;
false.
```

Стоит отметить, что при наличии нескольких детей у мужа и жены, пара тёща-муж будет выведена столько раз, сколько имеется детей, поскольку поиск основан на проверке наличия общего ребенка у мужа и жены. 

Работа предиката успешна, поскольку выведенная информация является достоверной.

## Определение степени родства

Определение степени родства – задача поиска в графе. Граф задан фактами родственных отношений отца, матери. Однако это крайне мало, поэтому дополнительно были описаны родственные отношения тёщи, мужа, жены, сына, дочери, брата, сестры, дедушки и бабушки. Для определения родства понадобится информация о поле индивидуума:

```prolog
% Определение пола индивидуума
female(Person) :- mother(Person,_), !.
male(Person) :- father(Person,_), !.
```
В качестве алгоритма поиска я выбрала поиск в ширину, так как логично находить сначала кратчайший путь, из-за чего поиск в глубину сразу же отсеивается. В поиске с итерационным заглублением необходимо ограничивать глубину погружения, что не будет удобным в данной задаче.

Реализация поиска в ширину:

```prolog
% Продление пути без зацикливания
prolong([X|T],[Y,X|T]):-
    move(X,Y,_),
    not(member(Y,[X|T])).

% Поиск в ширину    
bdth([[X|T]|_],X,[X|T]).

bdth([P|QI], X, R):-
    findall(Z, prolong(P, Z), T),
    append(QI, T, QQ), !,
    bdth(QQ, X, R).
    
bdth([_|T], Y, L):- bdth(T, Y, L).
    
bdth_search(X,Y,L):-
    bdth([[X]],Y,R), 
    reverse(R,L).
```

Результат работы:

```prolog
?- relative(X, "Алексей Минеев", "Валентина Кустова").
X = [mother_in_law] ;
X = [mother, wife] ;
X = [wife, father, wife] ;
X = [daughter, grandfather, wife] ;
X = [daughter, grandmother, wife] ;
X = [mother, brother, wife] ;
X = [mother, brother, wife] ;
X = [mother, son, father, wife] .

?- relative(X, "Светлана Минеева", "Ольга Минеева").
X = [mother] ;
X = [wife, father] ;
X = [daughter, grandfather] ;
X = [daughter, grandmother] ;
X = [daughter, mother_in_law, father] ;
X = [wife, son, grandfather] ;
X = [daughter, wife, grandfather] .

?- relative(X, "Светлана Минеева", "Владимир Минеев").
X = [grandfather] ;
X = [father, father] ;
X = [husband, grandmother] ;
X = [father, husband, mother] ;
X = [husband, mother, father] ;
X = [son, grandfather, father] ;
X = [son, grandmother, father] ;
X = [father, son, grandmother] .
```

Результат работы каждого из запросов я прерывала после вывода нескольких строк, так как количество цепочек родства большое количество. Определение степени родства успешно, поскольку вся выведенная информация является достоверной.

## Естественно-языковый интерфейс

Требуется реализовать естественно-языковой интерфейс к родословному дереву, чтобы можно было задавать вопросы относительно родства элементов дерева. Вопрос выглядит в виде списка и заканчивается вопросительным знаком. Также была реализована память заданных вопросов, то есть можно задавать вопросы с помощью местоимений him и her, ссылаясь на индивидуумов, введённых в предыдущем предложении.

Идея заключается в том, чтобы, принимая от пользователя вопрос, проверять его на корректность и в случае успеха строить ответ на заданный вопрос, используя реализованные ранее предикаты поиска родственников. 

```prolog
solution(Sentence):- solution(Sentence,[]).

solution --> to_be(N), subject(Slovo), object(X, Y, N), mark, 
             {first_answer(Slovo, X, Y)}, !, {writing_female(Slovo, X), writing_male(Slovo, X)}.

solution --> word, to_be(N), subject(First_person), object(Second_person), mark, 
             {second_answer(First_person, Second_person, 0)}, !, 
             {writing_female(First_person, Second_person), writing_male(First_person, Second_person)}.

solution --> word, to_be(N), object(X, Y, N), mark,
             {second_answer(0, X, Y)}, !, {writing_female(_, X)}.
            
solution --> words, relation(Word, speech), verb(N), subject(First_person), have(speech), mark,
             {singular(Word, Singular), third_answer(Singular, First_person)}, !, 
             {writing_female(_, First_person)}.
```

В интерфейсе используется английский язык, но имена и фамилия индивидуумов на русском языке, получилось на вид немного необычно, но всё равно понятно.

Результат работы:

```prolog
?- solution([who, is, "Ольга Минеева", for, "Светлана Минеева", ?]).
Ольга Минеева is Светлана Минеева's mother.
false.

?- solution([is, "Ольга Минеева", "Светлана Минеева", "'s", mother,?]).
Yes, Ольга Минеева is Светлана Минеева's mother.
false.

?- solution([Who, is, "Алексей Минеев", "'s", wife, ?]).
Ольга Минеева is Алексей Минеев's wife.

?- soluttion([is, "Алексей Минеев", "Ольга Минеева", "'s", husband,?]).
Yes, Алексей Минеев is Ольга Минеева's husband.
true.

?- soluttion([is, he, her, husband,?]).
Yes, Алексей Минеев is Ольга Минеева's husband.
true.
```

Результат работы успешен, поскольку выведенная информация является достоверной.

## Выводы

В процессе выполнения курсовой работы я получила важные теоретические и практические знания в области логического программирования. Я глубже изучила алгоритмы поиска, реализовав их с помощью логических и императивных языков программирования. В ходе этого, я осознала, что алгоритмы поиска на логическом языке программирования Prolog короче и элегантнее.

Очень интересным процессом было создание собственного родословного дерева, для этой цели существует простой и удобный online сервис Family Echo. Следующим открытием для меня стало то, что логический язык программирования Prolog хорошо подходит для написания парсера, его код получается максимально понятным.

Создание естественно-языкового интерфейса на Prolog в очередной раз доказало его удобство в решение подобных задач, однако описание естественного языка далось намного труднее, чем описание правил представления данных в формате GEDCOM. 

Итак, данная курсовая работа очень полезна, она даёт важные практические навыки в решении реалистичной задачи. Данная работа охватила все изученные темы, давая возможность ещё раз закрепить их.

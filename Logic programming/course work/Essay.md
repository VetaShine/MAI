# Реферат
## по курсу "Логическое программирование"

### студент: Минеева Светлана Алексеевна

## Сравнение реализации алгоритмов поиска на логических и императивных языках

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Погружаясь в изучение программирования, читая книги, статьи, общаясь с экспертами в данной сфере деятельности, невольно сталкиваешься с профессиональными терминами. Примером таких понятий является парадигма программирования. Но что же вообще такое парадигма? С древнегреческого слово «парадигма» означает «шаблон, образец, пример», из чего нетрудно понять его применение в области программирования, а также дать определение этому понятию. Парадигма программирования – это совокупность методов, правил, понятий, использующихся при написании программ. 

Впервые термин «парадигма программирования» применил американский учёный Роберт Флойд в 1978 году. Также он указал на большое различие использования данного понятия в сфере программирования от его применения в других областях науки – парадигмы программирования не являются несовместимыми, они могут успешно переплетаться в творческом процессе программиста. 

Уже очевидно существование различных парадигм программирования: императивное (процедурное), структурное, функциональное, логическое, объектно-ориентированное программирование и другие. Рассмотрим некоторые из них.

## Императивное программирование 

Императивный подход к программированию является одним из самых распространённых и популярных, его ещё называют традиционным. Первые языки компьютеров были императивными: машинные коды, Fortran, Algol, Assembler, Cobol, Basic и другие, ведь данный метод простой и понятный. Он заключается в представлении программы как последовательности инструкций, которую нужно выполнить для получения результата – изменения состояния с помощью переменных, операторов присваивания и составных выражений. Эти инструкции в языке программирования Assembler называют командами, а в языках высокого уровня – операторами. Такое представление программы даже больше похоже на приказы, что и подтверждается переводом с английского языка слова imperative – «приказ». 

Оценивая императивный подход программирования, можно отметить его большое преимущество: наличие чётких, прямых указаний делает код легко читаемым хоть программистам, хоть самому компьютеру, однако при написании императивной программы требуется строго описать все действия и способы хранения, преобразования информации, из-за чего программа выходит весьма масштабной.

Сейчас широкое применение имеют такие императивные языки программирования как Python, C, C++, Java, JavaScript, Go, Swift и другие. 

## Логическое программирование 

Логическое программирование появилось в связи с потребностью упрощения решения задач символьной обработки для математиков и лингвистов. Логический подход к программированию разительно отличается от императивного, можно сказать, что они противоположны. Если в императивном подходе нужно написать четкий ход действий для решения задачи, то в логическом требуется представить объекты задачи, описать их свойства, а также связи, отношения между ними. 

Логическая программа состоит из фактов (совокупности отношений объектов) и правил, благодаря которым создаются новые отношения. Логическая программа больше напоминает базу данных, поскольку не побуждает к действиям, а только описывает условия задачи. Работа программы начинается при задании ей запроса (того, что требуется найти), после чего происходит попытка логического вывода ответа на запрос на основе имеющихся фактов и правил. Подобные действия крайне напоминают мыслительные процессы человека при решении задач, то есть перебор возможных вариантов (в логических языках программирования – механизм бэктрекинга и отсеивание ложных вариантов). 

Логическое программирование имеет ряд преимуществ:
1)	Код получается компактным, из-за чего программа легко читается;
2)	Не нужно описывать алгоритм решения задачи;
3)	Логический язык программирования можно использовать как невычислительный язык, используя лишь выражения и факты;
4)	Результат не зависит от пути реализации практически всегда;
5)	Легко описываются сложные структуры данных, такие как списки, деревья и т.п.

Но можно выделить и недостатки логического программирования:
1)	Задачи, построенные на сложных вычислительных операциях, не будут иметь эффективного решения;
2)	Нельзя создавать комплексные задачи;
3)	Низкая производительность. Логические языки программирования уступают в этом императивным языкам программирования.

Язык программирования Planner был первым логическим языком программирования, названным так из-за необходимости написания правил перебора возможных вариантов, в совокупности называющихся планами. После появился логический язык программирования Prolog, являющийся популярным и в наше время, в нем не требуется написание планов.

## Алгоритмы поиска путей в графе

Рассмотрим различные алгоритмы поиска путей в графе, решая следующую задачу: определить все возможные пути в графе от одной заданной вершины до другой заданной вершины. 

До перехода к алгоритму действий поиска путей сначала нужно задать сам граф в программе. Существуют различные способы представления графов в программе, например, матрицами или списками смежности/инцидентности. Объекты графов часто хранятся в виде массивов, а в логическом языке программирования Prolog можно использовать базу данных или списки для этой цели. При частых изменениях графа его представление с помощью базы данных является лучшим вариантом.

Рассмотрим неориентированный граф, представленный на изображении ниже (в файле граф.jpg), с шестью вершинами и шестью рёбрами.

Опишем данный граф на логическом языке программирования Prolog в виде базы данных. В базе данных удобно описывать информацию о рёбрах графа (edge). Имена вершин соответствуют именам вершин на изображении выше. 

```prolog
edge(a, b). edge(a, f).
edge(b, d).
edge(c, e).
edge(d, e).
edge(e, f).
```

В данном графе нет изолированных вершин, поэтому граф можно описать лишь одними рёбрами, однако при наличии таких вершин в базе данных нужно дополнительно хранить информацию обо всех узлах графа (node). 

```prolog
node(a). node(b).
node(c). node(d).
node(e). node(f).
```

Рассмотрим ещё одно представление графов в программе – списки смежности. Идея заключается в создании для каждой вершины списка смежных с ней вершин. Приведём реализацию данного описания для графа, представленного на изображении выше, на императивном языке программирования Python.

```python
graph = {
	'a': ['b', 'f'], # вершины, смежные с вершиной a 
	'b': ['a', 'd'], 
	'c': ['e'], 
	'd': ['b', 'e'], 
	'e': ['c', 'd', 'f'], 
	'f': ['a', 'e'] 
}
```

Рассмотрим ещё один вид представления графов в программе – представление с помощью матриц смежности. Идея заключается в создании матрицы, где в один ряд значений (массив), соответствующему каждой из вершин, будем записывать значения единицы или нуля, обозначающие соответственно ответ True и False на следующий вопрос: «Правда ли, что есть путь из вершины «строки» в вершину «столбца»?». Приведём реализацию представления графа в виде матрицы смежности для графа, ранее представленного на изображении, на императивном языке программирования Python.

```python
a, b, c, d, e, f = range(6)
    # a b c d e f
graph = [[0,1,0,0,0,1], # a
        [1,0,0,1,0,0], # b
        [0,0,0,0,1,0], # c
        [0,1,0,0,1,0], # d
        [0,0,1,1,0,1], # e
        [1,0,0,0,1,0]] # f
```

Далее рассмотрим реализацию различных алгоритмов поиcка путей в графе на логическом языке программирования Prolog и императивном языке программирования Python (для представления графа в виде списка смежности).

## Алгоритмы поиска на логическом языке программирования Prolog

**Поиск в ширину**

Поиск в ширину состоит из поиска всех состояний, в которые можно перейти из текущего, потом этот процесс снова повторяется для найденных ранее состояний. Эти действия реализуются при помощи очереди путей. Поиск происходит пока не находится ответ или очередь, в конец которой добавляются найденные состояния, не окажется пустой, ведь если не удаётся продлить путь, то он удаляется.

Дополнительно самостоятельно реализуем стандартные предикаты, требующиеся для алгоритмов поиска:

```prolog
% Определение принадлежности элемента списку
mymember(X, [_|T]) :-
    mymember(X, T), !.
mymember(H, [H|_]). 

% Конкатенация списков в результирующий список
myappend([], L, L).
myappend([X|L1], L2, [X|L3]) :-
    myappend(L1, L2, L3).
```

Реализация поиска в ширину на Prolog:

```prolog
% Проверка наличия ребра между вершинами
move(X, Y):-
    edge(X, Y);
    edge(Y, X).

% Продление пути без зацикливания
prolong([X|T], [Y,X|T]) :-
    move(X, Y),
    not(mymember(Y, [X|T])). 

% Поиск в ширину
path(X, Y, P):- bdth([[X]], Y, P).

bdth([[X|T]|_], X, [X|T]).
bdth([P|QI], X, R):- findall(Z, prolong(P, Z), T),
                   myappend(QI, T, QO), !,
                   bdth(QO, X, R).
bdth([_|T], Y, L):- bdth(T, Y, L).
```

Результат работы программы:

```prolog
?- path(a, f, X).
X = [f, a]
X = [f, e, d, b, a]
false
```
Стоит отметить, что в данном алгоритме полученный в результате работы программы путь выводится в обратном порядке. 

Оценим реализацию алгоритма поиска в ширину на логическом языке программирования Prolog. Временная сложность равна O(b^Imax) = O(1 + b + b^2 + … + b^I) , где Imax – максимальная длина пути, b – среднее количество разветвлений вершины. Обход всего графа возможен в худшем случае. Пространственная сложность равна O(b^I), где I – длина пути, b – среднее количество разветвлений вершины.

У алгоритма поиска в ширину есть весьма много преимуществ: первый полученный результат работы алгоритма – это кратчайший путь, что очень важно, если требуется определить именно кратчайший путь; алгоритм можно использовать для нахождения путей с циклами.

**Поиск в глубину**

Поиск в глубину построен на попытке максимального углубления, в случае же отсутствия дальнейшего перехода происходят шаг назад и попытка углубления в другом направлении.
Реализация поиска в глубину на Prolog:

```prolog
% Поиск в глубину
path(X, Y, P):- dpth([X], Y, P).

dpth([X|T], X, [X|T]).
dpth(P, Y, R) :-
    prolong(P, P1),
    dpth(P1, Y, R).
```

Также ранее реализованный алгоритм поиска в ширину можно легко преобразовать в поиск в глубину. Для этого нужно поменять местами в предикате myappend T и QI, следовательно новые полученные пути будут добавляться в начало очереди, а не в конец.

```prolog
% Поиск в глубину
path(X, Y, P):- dpth([[X]], Y, P).

dpth([[X|T]|_], X, [X|T]).
dpth([P|QI], X, R):- findall(Z, prolong(P, Z), T),
                   myappend(T, QI, QO), !,
                   dpth(QO, X, R).
dpth([_|T], Y, L):- dpth(T, Y, L).
```

Результат работы программы:

```prolog
?- path(a, f, X).
X = [f, e, d, b, a]
X = [f, a]
false
```

Стоит отметить, что в данном алгоритме полученный в результате работы программы путь выводится в обратном порядке. 

Оценим реализацию алгоритма поиска в ширину на логическом языке программирования Prolog. Временная сложность равна O(b^Imax) = O(1 + b + b^2 + … + b^I) , где Imax – максимальная длина пути, b – среднее количество разветвлений вершины. Видно, что она совпадает с временной сложностью алгоритма поиска в ширину. Пространственная сложность равна O(Imax), так как требуется одновременное хранение лишь одного пути. По использованию памяти алгоритм поиска в глубину экономичней поиска в ширину, однако данный алгоритм необязательно первым находит кратчайший путь, что делает применение этого поиска не лучшим выбором в задаче, требующей нахождения кратчайшего пути, также поиск путей с циклами – не стихия алгоритма поиска в глубину.

## Алгоритмы поиска на императивном языке программирования Python

Реализовывать алгоритмы поиска мы будем с учётом представления графа в виде списка смежности, описанного ранее. Вообще описание графа в таком виде потребляет меньше памяти, однако если граф является плотным, то есть в нем большое количество рёбер, то матрицы смежности будут удобнее.

**Поиск в ширину**

Сама суть алгоритма поиска в ширину такая же, как и в логических языках программирования: ищем все состояния, в которые возможен переход из текущего состояния, помещая их в очередь, и далее двигаясь по очереди, повторяем этот процесс для каждого следующего состояния, в случае невозможности дальнейшего перехода просматриваемый путь удаляется. Так просматриваемые вершины как бы разделяются на уровни.

Реализация поиска в ширину на Python:

```python
# Поиск в ширину
from collections import deque

def bdth(graph, start, end):
    queue = deque([(start, [start])])
    while queue:
        (vertex, path) = queue.pop()
        for next in set(graph[vertex]) - set(path):
            if next == end:
                yield path + [next]
            else:
                queue.appendleft((next, path + [next]))

print(list(bdth(graph, 'a', 'f'))) # запрос поиска путей из вершины a в вершину f  и вывод результата в виде списка
```

Результат работы программы: 

```python
[['a', 'f'], ['a', 'b', 'd', 'e', 'f']]
```

Отметим, что полученные пути выводятся в прямом порядке. 

Оценим реализацию алгоритма поиска в ширину на императивном языке программирования Python. Временная сложность равна O(V + E), где V – количество вершин, E – количество рёбер, так как обход всего графа возможен в худшем случае. Пространственная сложность равна O(V + E), ведь все развёрнутые узлы хранятся в памяти.

**Поиск в глубину**

Суть алгоритма поиска в глубину такая же – попытка максимального углубления, в случае неуспеха же откат на шаг назад и попытка углубления в другом направлении.

Реализация поиска в глубину на Python:

```python
# Поиск в глубину
from collections import deque

def dpth(graph, start, end):
    stack = [(start, [start])]  
    while stack:
        (vertex, path) = stack.pop()
        for next in set(graph[vertex]) - set(path):
            if next == end:
                yield path + [next]
            else:
                stack.append((next, path + [next]))

print(list(dpth(graph, 'a', 'f'))) # запрос поиска путей из вершины a в вершину f  и вывод результата в виде списка
```

Результат работы программы: 

```python
[['a', 'f'], ['a', 'b', 'd', 'e', 'f']]
```

Отметим, что полученные пути выводятся в прямом порядке. 

Оценим реализацию алгоритма поиска в глубину на императивном языке программирования Python. Временная сложность равна O(V + E), где V – количество вершин, E – количество рёбер. Пространственная сложность равна O(V), где V – количество вершин. 

## Заключение

В итоге, были реализованы основные алгоритмы поиска на логических и императивных языках программирования. Представителем от логических языков программирования стал Prolog, а от императивных – Python. В целом, реализации получились достаточно похожими ввиду единых алгоритмов, однако уникальность каждого из языков, парадигм программирования оставила свой след в коде.  

В Prolog код получается элегантным и очень компактным, из-за чего становится удобным для чтения и понимания. Однако в этом плане императивный язык программирования Python тоже показал себя крайне успешно, ведь разница функций алгоритмов поиска на двух языках составляет всего пару-тройку строк не в пользу Python. Хотя подобный результат легко можно объяснить особенностями самого языка программирования, которыми не могу похвастаться остальные императивные языки программирования. Явно, реализация алгоритмов поиска на таких императивных языках программирования как C, C++, Java выглядели бы более масштабно.

Представление алгоритмов поиска в виде правил дискретной математики в логическом языке программирования Prolog также делает код читабельным, красивым, но вот скорость работы из-за этого снижается. Императивные языки программирования оказываются более шустрыми.

Выбор между реализацией алгоритмов поиска на императивных языках программирования и их воплощением на логических языках зависит от условий решаемой задачи, а также от личных предпочтений. Логические языки программирования компактнее, а императивные языки программирования эффективнее по времени работы.

## Список использованной литературы

1.	Д.В. Сошников «Парадигма логического программирования»;
2.	Г.М. Сергиевский «Функциональное и логическое программирование»;
3.	А.А. Тюгашев «Основы программирования».

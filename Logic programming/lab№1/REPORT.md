# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Минеева Светлана Алексеевна

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В Prolog есть такая структура данных как список, которая предназначена для хранения не только отдельных элементов, но и их наборов. В Prolog список – это либо пустой элемент, либо «голова с хвостом». К первому узлу списка (голове) присоединяются остальные узлы (хвост списка). Хвост списка тоже является списком. Списки в языке Prolog отличаются от принятых в императивных языках подходов к хранению данных. В Prolog элементы списка могут быть совершенно разными объектами. Также, в императивных языках программирования список – это набор связанных между собой элементов, в Prolog же – это бинарное дерево. Для навигации в списке в Prolog используется рекурсия, а в императивных языках – итераторы, обращение по индексу. В данной лабораторной работе мне предлагается подробнее изучить такую структуру данных в Prolog как список.

**Реализация стандартных предикатов**

1) `mylen(L, N)` - определение длины N списка L

Примеры использования:
```prolog
?- mylen([1,2,3], X)
X = 3

?- mylen([], X)
X = 0

?- mylen([5,-1,2,5], 4)
true

?- mylen([5,-1,2], 4)
false
```

Реализация:
```prolog
mylen([], 0).
mylen([_|T], N) :-
    mylen(T, N1),
    N is N1+1, !.
```

В SWI Prolog имеется встроенный предикат `length`, я реализовала аналогичный предикат `mylen`.

Принцип работы предиката: Если список – пустой, то его длина равна нулю, иначе проходим рекурсивно по хвосту списка, подсчитывая количество элементов, в конце прибавляем единицу.

2) `mymember(X, L)` - определение принадлежности элемента X списку L

Примеры использования:
```prolog
?- mymember(1, [1,2,3])
true

?- mymember(5, [1,2,3])
false
```

Реализация:
```prolog
mymember(X, [_|T]) :-
    mymember(X, T), !.
mymember(H, [H|_]).
```

В SWI Prolog имеется встроенный предикат `member`, я реализовала аналогичный предикат `mymember`.

Принцип работы предиката: Если список начинается с элемента X, то принадлежность списку сразу принимает значение истина, иначе проходим по хвосту списка рекурсивно, сравнивая его элементы с X.

3) `myappend(X, Y, Z)` - конкатенация списков X и Y в результирующий список Z

Примеры использования:
```prolog
?- myappend([1,1],[1,2,3], Z)
Z = [1, 1, 1, 2, 3]

?- myappend([],[], Z)
Z = []

?- myappend([],[1,2], Z)
Z = [1, 2]
```

Реализация:
```prolog
myappend([], L, L).
myappend([X|L1], L2, [X|L3]) :-
    myappend(L1, L2, L3).
```

В SWI Prolog имеется встроенный предикат `append`, я реализовала аналогичный предикат `myappend`.

Принцип работы предиката: Если выполняется конкатенация пустого списка и какого-то другого списка, то результатом будет второй список. Иначе отделяем голову первого списка, добавляем ее в результирующий список. Хвост результирующего списка назовём Z. Далее рекурсивно выполняем конкатенацию первого списка без головы и второго списка, полученный результат подставляем на место списка Z.

4) `rm(X, Y, Z)` - удаление элемента X из списка Y и помещение результата в список Z

Примеры использования:
```prolog
?- rm(2, [1,2,3,4], Z)
Z = [1, 3, 4]

?- rm(5, [1,2,3,4], Z)
false

?- rm(-1, [-3, 0, -1], Z)
Z = [-3, 0]
```

Реализация:
```prolog
rm(X, [X|T], T).
rm(X, [M|T], [M|T1]) :-
    rm(X, T, T1), !.
```

Принцип работы предиката: Если удаляемый элемент – это голова списка, то резултат – это список с отсеченной головой. Иначе рекурсивно проходим по списку, пытаясь удалить нужный элемент. Если дошли до конца списка, а этот элемент не был найден, то выводится false.

5) `mypermute(X, Y)` -  перестановка элементов списка X

Примеры использования:
```prolog
?- mypermute([1,2,3], X)
X = [1, 2, 3]
X = [1, 3, 2]
X = [2, 1, 3]
X = [3, 1, 2]
false

?- mypermute([1,2,3], [3,2,1])
true
false

?- mypermute([1,2,3], [3,2,4])
false

?- mypermute([], X)
X = []
```

Реализация:
```prolog
mypermute([], []).
mypermute([X|T], R) :-
    rm(X, R, T1),
    mypermute(T, T1).
```

Принцип работы предиката: Перестановка пустого списка – пустой список. Если список непустой, то нужно удалить первый элемент и рекурсивно выполнить перестановку полученного списка, после удаленный элемент добавить в голову новой перестановки.

6) `mysublist(L, T)` -  проверка на то, является ли L подсписком списка T

Примеры использования:
```prolog
?- mysublist([1], [1,2,3])
true

?- mysublist([4], [1,2,3])
false

?- mysublist([], [1,2,3])
true
```

Реализация:
```prolog
mysublist(L, T) :-
    myappend(Sublist, _, T),
    myappend(_, L, Sublist), !.
```

Принцип работы предиката: Список L является подсписком списка T, если для списка T существует подсписок, равный L, что мы сможем проверить с помощью реализованного раннее предиката `myappend`.

## Задание 1.1: Предикат обработки списка

`replace(X, N, L, Res)` - замена N-го элемента на указанный (на X). Нумерация начинается с нуля.

Примеры использования:
```prolog
?- replace(x,1,[p,'SSS',de],Res).
Res = [p, x, de]

?- replace(x,4,[p,'SSS',de],Res).
false

?- stdreplace(x,0,[p,f,sj,'SSS',de],Res).
Res = [x, f, sj, 'SSS', de]

?- stdreplace(x,5,[p,f],Res).
false
```

Реализация:
```prolog
replace(X,0,[_|L],Res):-
    myappend([X],L,Res),!.
replace(X,N,[H|L],Res):-
    N1 is N - 1,
    replace(X,N1,L,R),
    myappend([H],R,Res),!.

% со стандартными предикатами:
stdreplace(X, N, L, Res) :-
    N>=0,
    length(HelpL, N),
    append(HelpL, Tail, L),
    [_|TTail]=Tail,
    append(HelpL, [X|TTail], Res).
```

Принцип работы предиката: Изначально отработает второе определение предиката, а при окончании рекурсии (N станет равным нулю) отработает первое определение предиката и отсечется N-ый элемент. Предикат `myappend` создаст новый список, головой которого будет X, а хвостом – остальная часть списка.

## Задание 1.2: Предикат обработки числового списка

`separation(L, Less, More)` - разделение списка на два относительно первого элемента (по принципу «больше-меньше»)

Примеры использования:
```prolog
?- separation([2,10],Less,More).
Less = [],
More = [10]

?- separation([4,5,5],Less,More).
Less = [],
More = [5,5]

?- separation([0,-5,8,2,23,-1],Less,More).
Less = [-5,-1],
More = [8,2,23]

?- separation([3,1,1,1],Less,More).
Less = [1,1,1],
More = []

?- stdseparation([3,1,5,7],Less,More).
Less = [1],
More = [5,7]

?- stdseparation([4,4,-2,7],Less,More).
Less = [-2],
More = [7]

?- stdseparation([],Less,More).
false

?- stdseparation([5,1],Less,More).
Less = [1],
More = []
```

Реализация:
```prolog
separation(_, [], [], []).
separation(X, [H|L], Less, More) :-
    (   H>X,
        separation(X, L, Less, More1), !,
        myappend([H], More1, More)
    ;   H<X,
        separation(X, L, Less1, More), !,
        myappend([H], Less1, Less)
    ;   H is X,
        separation(X, L, Less, More)
    ).

separation([X|L], Less, More) :-
    separation(X, L, Less, More).

% со стандартными предикатами:
stdseparation([X|L],Less,More):-
    findall(N,(member(N,L),N < X),Less),
    findall(N,(member(N,L),N > X),More).
```

Принцип работы предиката: Проходим по списку и сравниваем элементы списка с первым элементом: если элемент меньше первого, то он добавляется в конец первого списка, если элемент больше первого, то во второй, а если элемент равен первому, то он пропускается.

**Совместное использование реализованных предикатов**

```prolog
?- L = [5,-1,6,9,2],nl,nl,
write("List is "), write(L), mylen(L,N),
write(", its length is "), write(N),nl,
write("Change element 2 to \'b\', "),
replace(b, 2, L, X), write("new list is: "), write(X), nl,
write("Remove 6 from list, "),
rm(6, L, T), write("new list is: "), write(T),
write(", its length is "), mylen(T, N1), write(N1), nl,
write("Split the list "), write(L), write(" in two: "),
separation(L, Less, More), write("Less = "), write(Less), 
write(", More = "), write(More).

List is [5, -1, 6, 9, 2], its length is 5
Change element 2 to 'b', new list is: [5, -1, b, 9, 2]
Remove 6 from list, new list is: [5, -1, 9, 2], its length is 4
Split the list [5, -1, 6, 9, 2] in two: Less = [-1, 2], More = [6, 9]
L = [5, -1, 6, 9, 2],
Less = [-1, 2],
More = [6, 9],
N = 5,
N1 = 4,
T = [5, -1, 9, 2],
X = [5, -1, b, 9, 2]
```

## Задание 2: Реляционное представление данных

Бывает, для решения задачи нам удобно использовать реляционное представление данных, которое имеет ряд преимуществ и недостатков. Достоинствами данного представления являются простота, строгие правила проектирования и независимость данных. Большой расход памяти и низкая скорость при выполнении операции соединения же являются минусами реляционного представления данных.

Представление данных в моём варианте:
```prolog
grade(группа, фамилия, предмет, оценка)
```
Очень легко и понятно выглядит данное представление, однако оно намного объёмнее других вариантов представления данных.

Реализуем все предикаты, осуществляющие запросы к данным, нужные для решения задания.

1) `subjects(X)` - возвращение списка всех предметов

Примеры использования:
```prolog
?- subjects(X).
X = ['Английский язык', 'Информатика', 'Логическое программирование', 'Математический анализ', 'Психология', 'Функциональное программирование']
```

Реализация:
```prolog
subjects(L) :- setof(Subject, A^B^C^grade(A, B, Subject, C), L).
```

Принцип работы предиката: Ищем все предметы, встречающиеся в базе данных. Остальные данные не конкретизируются.

2) `sum(L, X)` - подсчёт суммы элементов списка L

Примеры использования:
```prolog
?- sum([],X).
X = 0
?- sum([3,4,5],X).
X = 12

?- sum([1],1).
true

?- sum([1,2],1).
false
```

Реализация:
```prolog
sum([], 0).
sum([H|T], Sum) :- sum(T, Sum1), Sum is Sum1 + H.
```

Принцип работы предиката: Если список – пустой, то сумма элементов списка равна нулю, иначе, отделяя голову списка, рекурсивно проходим по хвосту списка, считая сумму этих элементов, в конце к полученной сумме прибавляем значение головы.

3) `average(L, X)` - нахождение среднего значения списка L.

Примеры использования:
```prolog
?- average([2,2], X).
X = 2

?- average([2,4,9], X).
X = 5

?- average([3,7,6,9], X).
X = 6.25

?- average([1,2,3], 2).
true

?- average([1,2,3], 3).
false
```

Реализация:
```prolog
average(L, X) :- sum(L, Sum), length(L, Length), X is Sum / Length.
```

Принцип работы предиката: Так как среднее значение элементов списка – это сумма значений элементов списка, поделенная на количество элементов списка, то подсчитываем сумму элементов списка при помощи написанного раннее предиката `sum(L, X)` и делим на длину списка.

**Задание №1. Напечатать средний балл для каждого предмета**

`average_grade(S, N)` - нахождение среднего балла N по предмету S

Примеры использования:
```prolog
?- average_grade('Психология', N).
N = 3.9285714285714284

?- average_grade('Математический анализ', N).
N = 3.892857142857143

?- average_grade('Математический анализ', 3).
false
```

Реализация:
```prolog
average_grade(S, N) :- findall(M, grade(_, _, S, M), L),  average(L, N).
```
Принцип работы предиката: Используя предикат `findall`, получаем список всех оценок по предмету S, после находим среднее значение элементов списка.

`print_average_grades(S, X)` - вывод среднего балла по всем предметам

Примеры использования:
```prolog
?- print_average_grades(X, Y).
X = 'Английский язык',
Y = 3.75 
X = 'Информатика',
Y = 3.9285714285714284 
X = 'Логическое программирование',
Y = 3.9642857142857144 
X = 'Математический анализ',
Y = 3.892857142857143 
X = 'Психология',
Y = 3.9285714285714284 
X = 'Функциональное программирование',
Y = 3.9642857142857144
```

Реализация:
```prolog
print_average_grades(Subject, Average) :- subjects(Subjects), member(Subject, Subjects), average_grade(Subject, Average).
```

Принцип работы предиката: Вызываем предикат `average_grade` для вычисления среднего балла для каждого предмета из списка, созданного предикатом `subjects`.

**Задание №2. Для каждой группы, найти количество не сдавших студентов**

`print_failed_exam(G, N)` - нахождение и вывод количества не сдавших студентов группы G

Примеры использования:
```prolog
?- print_failed_exam(X, Y).
X = 101,
Y = 2
X = 102,
Y = 5
X = 103,
Y = 3
X = 104,
Y = 2
```

Реализация:
```prolog
print_failed_exam(G, N) :- setof(Student, A^grade(G, Student, A, 2), L), length(L, N).
```

Принцип работы предиката: Используя предикат `setof` составляем список студентов, у которых есть двойка за какой-либо предмет, длина полученного списка – искомое значение.

**Задание №3. Найти количество не сдавших студентов для каждого из предметов**

`failed_subject(S, N)` - нахождение количества студентов, не сдавших предмет S

Примеры использования:
```prolog
?- failed_subject('Психология', X).
X = 1

?- failed_subject('Информатика', X).
X = 2

?- failed_subject('Информатика', 1).
false
```

Реализация:
```prolog
failed_subject(S, N) :- findall(Student, grade(_, Student, S, 2), L), length(L, N).
```

Принцип работы предиката: Используя предикат `findall`, получаем список студентов с двойкой по предмету S, длина полученного списка – искомое значение.

`print_failed_subject(S, N)` - вывод списка всех предметов и количества студентов, не сдавших этот предмет

Примеры использования:
```prolog
X = 'Английский язык',
Y = 4
X = ‘Информатика’
Y = 2
X = 'Логическое программирование',
Y = 2
X = ‘Математический анализ’
Y = 3
X = 'Психология',
Y = 1
X = 'Функциональное программирование',
Y = 1
```

Реализация:
```prolog
print_failed_subject(Subject, Number) :- subjects(Subjects), member(Subject, Subjects), failed_subject(Subject, Number).
```

Принцип работы предиката: Используем предикат `failed_subject` для списка всех предметов, созданного с помощью предиката `subjects`.

## Выводы

В данной лабораторной работе я познакомилась со списками в языке Prolog, реализация которых весьма особенна и очень удобна для работы. Списки получаются наглядными, простыми и понятными. Обработка этих списков осуществляется с помощью предикатов, которые реализуются чаще всего с помощью рекурсии. 

Списки также можно использовать для реляционного представления данных, полученная база данных легко воспринимается глазом, она максимально понятна, но несмотря на это, большой расход памяти и низкая скорость при выполнении операции соединения становятся её минусами.

Изучение языка программирования Prolog очень хорошо развивает мышление, поскольку он отличается от императивных языков программирования, поэтому при работе на нём требуется отказаться от стереотипов императивного программирования. Логическое программирование учит нас искать нетривиальный подход для решения задач. 

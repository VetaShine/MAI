#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Минеева Светлана Алексеевна

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Решение многих задач определяется как проблема поиска, в котором цель поиска – это искомое решение, а множество путей достижения данной цели представляет собой пространство состояний. Решение таких задач можно представить в виде графа, в качестве вершин которого выступают состояния, а в качестве ребер графа – возможные переходы между состояниями. Следовательно, задачи, в которых задано начальное и конечное состояние и количество всевозможных состояний конечно, удобным образом решаются методом поиска в пространстве состояний.

Работа языка программирования Prolog состоит в поиске всех возможных соответствий между фактами и правилами, что является важным для метода поиска в пространстве состояний. Также в данном языке программирования граф описывается предикатами путем перечисления всех дуг, что более гибко, чем его описание в виде матрицы смежности. Итак, Prolog – удобный язык программирования для решения задач методом поиска в пространстве состояний.

## Задание

6. Вдоль доски расположено 8 лунок, в которых лежат 4 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые – на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром. При этом черные шары можно передвигать только вправо, а белые – только влево.

## Принцип решения

Для решения задачи нужно задать логические шаги переходов между состояниями. В данной задаче число данных шагов равно четырём:

1)	Если пустая лунка слева от белого шара, то перемещаем этот шар в пустую лунку;
2)	Если пустая лунка справа от черного шара, то перемещаем этот шар в пустую лунку;
3)	Если пустая лунка находится слева и непосредственно за ближайшим шаром от белого шара, то перемещаем этот шар в пустую лунку;
4)	Если пустая лунка находится справа и непосредственно за ближайшим шаром от черного шара, то перемещаем этот шар в пустую лунку.

```prolog
% Логические шаги
act(A,B):-
    myappend(S, ["_","w"|T], A),
    myappend(S, ["w","_"|T], B).

act(A,B):-
    myappend(S, ["b","_"|T], A),
    myappend(S, ["_","b"|T], B).

act(A,B):-
    myappend(S, ["_","b","w"|T], A),
    myappend(S, ["w","b","_"|T], B).

act(A,B):-
    myappend(S, ["b","w","_"|T], A),
    myappend(S, ["_","w","b"|T], B).
```

Нам потребуется предикат для вывода последовательности лунок:

```prolog
% Вывод решения
print_solution([]).
print_solution([B|T]):-
    print_solution(T),
    write(B), nl.
```

Для работы алгоритмов потребуется предикат, который будет продлевать пути в графе, предотвращая зацикливания:

```prolog
% Продление пути без зацикливания
prolong([X|T], [Y,X|T]) :-
    act(X, Y),
    not(mymember(Y, [X|T])). 
```

В данной работе я реализовала три алгоритма поиска: поиск в глубину, в ширину и в глубину с итерационным погружением.

**Поиск в ширину**

Поиск в ширину состоит из поиска всех состояний, в которые можно перейти из текущего. После эти действия снова проделываются для найденных состояний. Данный поиск происходит пока не находится ответ или очередь, в конец которой добавляются найденные состояния, не окажется пустой.

```prolog
bdth([[X|T]|_], X, [X|T]).

bdth([P|QI], X, R):- findall(Z, prolong(P, Z), T),
                   myappend(QI, T, QO), !,
                   bdth(QO, X, R).

bdth([_|T], Y, L):- bdth(T, Y, L).
```

**Поиск в глубину**

Поиск в глубину построен на попытке максимального углубления, в случае же отсутствия дальнейшего перехода происходят шаг назад и попытка углубления в другом направлении.

Реализованный алгоритм поиска в ширину легко преобразовать в поиск в глубину. Для этого нужно поменять местами в предикате `myappend` T и QI, следовательно новые полученные пути будут добавляться в начало очереди, а не в конец. 

```prolog
% Поиск в глубину
dpth([[X|T]|_], X, [X|T]).

dpth([P|QI], X, R):- findall(Z, prolong(P, Z), T),
                   myappend(T, QI, QO), !,
                   dpth(QO, X, R).

dpth([_|T], Y, L):- dpth(T, Y, L).
```

**Поиск в глубину с итеративным погружением**

Поиск в глубину с итеративным погружением схож с поиском в глубину, но он построен не на максимальном углублении, а на поиске ответа среди путей длины, равной одному, после длины, равной двум, и так далее. 

В поиске ограничивается глубина погружения параметром N. Для увеличения данного параметра реализован предикат `for`.

```prolog
% Поиск в глубину с итеративным погружением
dpth_id([X|T], X, [X|T], 0).

dpth_id(X, Y, P, N) :- 
    N > 0, 
    prolong(X, XX), 
    N1 is N - 1, 
    dpth_id(XX, Y, P, N1).

for(X, X, _).
for(I, X, Y):-
    X < Y,
    X1 is X + 1,
    for(I, X1 ,Y).
```

## Результаты

```prolog
?- solve(["b","b","b","b","_","w","w","w"],["w","w","w","_","b","b","b","b"]).

ITERATIVE-DEEPENING DEPTH-FIRST SEARCH
[b, b, b, b, _, w, w, w]
[b, b, b, b, w, _, w, w]
[b, b, b, _, w, b, w, w]
[b, b, _, b, w, b, w, w]
[b, b, w, b, _, b, w, w]
[b, b, w, b, w, b, _, w]
[b, b, w, b, w, b, w, _]
[b, b, w, b, w, _, w, b]
[b, b, w, _, w, b, w, b]
[b, _, w, b, w, b, w, b]
[_, b, w, b, w, b, w, b]
[w, b, _, b, w, b, w, b]
[w, b, w, b, _, b, w, b]
[w, b, w, b, w, b, _, b]
[w, b, w, b, w, _, b, b]
[w, b, w, _, w, b, b, b]
[w, _, w, b, w, b, b, b]
[w, w, _, b, w, b, b, b]
[w, w, w, b, _, b, b, b]
[w, w, w, _, b, b, b, b]
TIME: 0.9849400520324707

DEPTH-FIRST SEARCH
[b, b, b, b, _, w, w, w]
[b, b, b, b, w, _, w, w]
[b, b, b, _, w, b, w, w]
[b, b, _, b, w, b, w, w]
[b, b, w, b, _, b, w, w]
[b, b, w, b, w, b, _, w]
[b, b, w, b, w, b, w, _]
[b, b, w, b, w, _, w, b]
[b, b, w, _, w, b, w, b]
[b, _, w, b, w, b, w, b]
[_, b, w, b, w, b, w, b]
[w, b, _, b, w, b, w, b]
[w, b, w, b, _, b, w, b]
[w, b, w, b, w, b, _, b]
[w, b, w, b, w, _, b, b]
[w, b, w, _, w, b, b, b]
[w, _, w, b, w, b, b, b]
[w, w, _, b, w, b, b, b]
[w, w, w, b, _, b, b, b]
[w, w, w, _, b, b, b, b]
TIME: 2.599400043487549

BREADTH-FIRST SEARCH
[b, b, b, b, _, w, w, w]
[b, b, b, b, w, _, w, w]
[b, b, b, _, w, b, w, w]
[b, b, _, b, w, b, w, w]
[b, b, w, b, _, b, w, w]
[b, b, w, b, w, b, _, w]
[b, b, w, b, w, b, w, _]
[b, b, w, b, w, _, w, b]
[b, b, w, _, w, b, w, b]
[b, _, w, b, w, b, w, b]
[_, b, w, b, w, b, w, b]
[w, b, _, b, w, b, w, b]
[w, b, w, b, _, b, w, b]
[w, b, w, b, w, b, _, b]
[w, b, w, b, w, _, b, b]
[w, b, w, _, w, b, b, b]
[w, _, w, b, w, b, b, b]
[w, w, _, b, w, b, b, b]
[w, w, w, b, _, b, b, b]
[w, w, w, _, b, b, b, b]
TIME: 2.74537992477417


true
```

| Алгоритм поиска |  Длина найденного первым пути  |     Время работы     |
|-----------------|--------------------------------|----------------------|
| В глубину       |               20               |   2.74537992477417   |
| В ширину        |               20               |   2.599400043487549  |
| ID              |               20               |   0.9849400520324707 |

## Выводы

В данной лабораторной работе я изучила алгоритмы поиска и их реализацию на языке программирования Prolog, сравнила работу стратегий поиска в ширину, в глубину и в глубину с итерационным погружением. 

Реализованные алгоритмы успешно решили поставленную задачу, однако в данном случае намного эффективнее оказался метод поиска в глубину с итерационным погружением, хотя, казалось бы, в этом поиске много раз проходятся одни и те же пути. Однако результат может отличаться при задании другого начального и конечного состояния, то есть при изменении графа. 

Поиск в ширину расточителен и по времени, и по памяти, однако первым он находит кратчайший путь, а также позволяет искать в путях с циклами. Поиск в глубину также расточителен по времени, но экономичен по памяти. Первым на вывод в этом поиске поступает просто первый найденный путь, а не кратчайший. Следовательно, если при выполнении задачи важна экономия памяти, то следует выбрать метод поиска в глубину, но, если нужно найти кратчайший путь, то явно метод поиска в ширину будет правильным выбором. Поиск в глубину с итеративным погружением первым тоже находит кратчайший путь, а ещё он избегает экспоненциальной сложности, но подходит лишь для легких задач.
